<?xml version="1.0" encoding="utf-8" ?>
<article>
  <articleinfo>
    <title>DynamicalSystems.jl: A Julia software library for chaos and nonlinear dynamics</title>
    <authors>
      <author>
        <name>George Datseris</name>
        <orcid>0000-0002-6427-2385</orcid>
        <affiliation>
          <orgname>
            1
          </orgname>
        </affiliation>
      </author>
    </authors>
    <tags>
      <tag>chaos</tag>
      <tag>physics</tag>
      <tag>nonlinear</tag>
      <tag>lyapunov</tag>
      <tag>entropy</tag>
      <tag>dimension</tag>
    </tags>
    <date>24 February 2018</date>
    <paper_doi>10.21105/joss.00598</paper_doi>
    <software_repository>https://github.com/JuliaDynamics/DynamicalSystems.jl</software_repository>
    <software_archive>http://dx.doi.org/10.5281/zenodo.1198278</software_archive>
    <paper_url>http://www.theoj.org/joss-papers/joss.00598/10.21105.joss.00598.pdf</paper_url>
  </articleinfo>
  <body>
    <h1 id="introduction">Introduction</h1>
    <p>Chaotic systems are everywhere <span class="citation" data-cites="Strogatz">(Strogatz 1995)</span>, from celestial mechanics to biology to electron transport. Not only do they cover many scales, but the phenomena that fall under the scope of “nonlinear dynamics” are multi-faceted <span class="citation" data-cites="Faust2015">(Faust et al. 2015)</span>. This vast extent of chaotic systems requires the use of methods from nonlinear dynamics and chaos theory in many diverse areas of science.</p>
    <p>On the other hand, chaotic systems are not analytically solvable, therefore studying them often relies on numerical methods. Many such methods have been devised to study the many facets of nonlinear systems, but unfortunately no up-to-date and comprehensive library collecting these methods exists.</p>
    <h1 id="enter-dynamicalsystems.jl">Enter <strong>DynamicalSystems.jl</strong></h1>
    <p><strong>DynamicalSystems.jl</strong> was created to fill this role. It is a Julia <span class="citation" data-cites="Bezanson2017">(Bezanson et al. 2017)</span> library that offers functionality useful in the study of chaos, nonlinear dynamics and time-series analysis. <strong>DynamicalSystems.jl</strong> itself is also a part of the <a href="https://github.com/JuliaDynamics">JuliaDynamics</a> organization, similarly with the package DynamicalBilliards.jl <span class="citation" data-cites="Datseris2017">(Datseris 2017)</span>.</p>
    <p>The official documentation is hosted <a href="https://juliadynamics.github.io/DynamicalSystems.jl/latest/">here</a>.</p>
    <h2 id="dynamicalsystems.jl-goals"><strong>DynamicalSystems.jl</strong> Goals</h2>
    <p>Our goals with this library can be summarized as:</p>
    <ol type="1">
    <li>Be concise, intuitive, and general.</li>
    <li>Be accurate, reliable and performant.</li>
    <li>Be transparent with respect to what is happening “under the hood”, i.e. be clear about exactly what each function call does. We take care of this aspect in many ways; by being well-documented, giving references to scientific papers and having clear source code.</li>
    </ol>
    <h2 id="features">Features</h2>
    <ul>
    <li>General &amp; flexible dynamical system definition interface.</li>
    <li>Automatic computation of Jacobians through automatic differentiation.</li>
    <li>Dedicated interface for datasets, including IO.</li>
    <li>Delay coordinates embedding.</li>
    <li>Poincaré surface of sections.</li>
    <li>Orbit diagrams (also called bifurcation diagrams).</li>
    <li>Automated production of orbit diagrams for continuous systems.</li>
    <li>Maximum Lyapunov exponent.</li>
    <li>Spectrum of Lyapunov exponents.</li>
    <li>Generalized entropies &amp; permutation entropy.</li>
    <li>Generalized dimensions and automated procedure of deducing them.</li>
    <li>Neighborhood estimation of points in a dataset.</li>
    <li>Numerical (maximum) Lyapunov exponent of a timeseries.</li>
    <li>Finding fixed points of a map of any order.</li>
    <li>Detecting and distinguishing chaos using the GALI method.</li>
    </ul>
    <p>We advise the reader to visit the latest <a href="https://juliadynamics.github.io/DynamicalSystems.jl/latest/#contents">overview</a> because new methods are constantly enriching <strong>DynamicalSystems.jl</strong>.</p>
    <h2 id="similar-existing-software">Similar existing software</h2>
    <p>We would now like to mention three other software packages that offer similar functionality to ours. We are only considering open-sourced packages in this section.</p>
    <p>The first, <a href="http://www.physik3.gwdg.de/tstool/index.html">TSTOOL</a>, is aimed at nonlinear time series analysis and is implemented in MATLAB (which is Proprietary software) with a partial backend of C++. Features of TSTOOLS that are not currently offered by <strong>DynamicalSystems.jl</strong> are surrogate time-series and estimating suitable dimensions for delay coordinates embedding. TSTOOL operates on datasets, and thus any dataset can easily be loaded through the provided interface, but there is no definition of equations of motion. This has the result that all methods contained cannot take advantage of known equations of motion.</p>
    <p>The second, E&amp;F chaos <span class="citation" data-cites="Diks2008">(Diks et al. 2008)</span>, is implemented in LUA with a partial C/Pascal backend and is aimed at nonlinear dynamics in economics and finance. Features of E&amp;F chaos that we do not offer are basin boundary plots, cobwebs and parameter basins. E&amp;F chaos is the only software mentioned here that allows definition of new systems through equations of motion.</p>
    <p>Finally, LP-VIcode <span class="citation" data-cites="Carpintero2014">(Carpintero, Maffione, and Darriba 2014)</span> is a suite devoted solely for computing variational indicators of chaos and is written in FORTRAN77. <strong>DynamicalSystems.jl</strong> offers only the latest indicator from all the ones available in LP-VIcode, namely GALI <span class="citation" data-cites="Skokos2007">(Skokos, Bountis, and Antonopoulos 2007)</span>. In addition, LP-VIcode places the severe constrain that all systems must not only be Hamiltonian, but must also have parabolic kinetic energy term, making it unusable for any other system type, Hamiltonian or not.</p>
    <h3 id="dynamicalsystems.jl-advantages-vs-other-packages"><strong>DynamicalSystems.jl</strong> advantages vs other packages</h3>
    <ul>
    <li>It is written in purely in Julia <span class="citation" data-cites="Bezanson2017">(Bezanson et al. 2017)</span>.
    <ul>
    <li>Julia is (currently) the only open sourced &amp; dynamic language that has performance equal to C/Fortran, allowing interactivity without adding computational costs.</li>
    </ul></li>
    <li>Fully exposes the differential equation solvers of continuous systems, and gives the user the (possible) full control over them through the DifferentialEquations.jl suite <span class="citation" data-cites="Rackauckas2017">(Rackauckas and Nie 2017)</span>.</li>
    <li>Offers the widest range of methods.</li>
    <li>Transparent and small source code.</li>
    <li>It is concise, intuitive and general: all functions work just as well with any defined dynamical system.</li>
    <li>Extendable; adding new systems or algorithms requires minimal effort.</li>
    <li>Actively maintained and constantly growing.</li>
    <li>Hosted on GitHub, making interaction of users and developers easy and straightforward.</li>
    </ul>
    <h1 id="examples">Examples</h1>
    <p>In the following examples we want to demonstrate some of the capabilities of <strong>DynamicalSystems.jl</strong>. In the first example will show how one can find the Lyapunov spectrum of a continuous system, while the second will show how to use delay coordinates embedding to calculate the attractor dimension from a time series. Both examples are benchmarked on a laptop with Intel(R) Core(TM) i5-6200U CPU @ 2.30 Ghz, 8GB RAM, 64-bit Windows 10 operating system and Julia version v0.6.2.</p>
    <h2 id="lyapunov-spectrum-of-a-continuous-system">Lyapunov spectrum of a continuous system</h2>
    <p>The first step is to create a <code>DynamicalSystem</code> structure:</p>
    <div class="sourceCode" id="cb1"><pre class="sourceCode julia"><code class="sourceCode julia"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co"># Pkg.add(&quot;DynamicalSystems&quot;)</span></a>
    <a class="sourceLine" id="cb1-2" data-line-number="2">using DynamicalSystems</a>
    <a class="sourceLine" id="cb1-3" data-line-number="3"><span class="co"># Define Lorenz system: equations take the current state `u`</span></a>
    <a class="sourceLine" id="cb1-4" data-line-number="4"><span class="co"># with parameters `p` at time `t` and return an SVector</span></a>
    <a class="sourceLine" id="cb1-5" data-line-number="5"><span class="co"># with the derivatives.</span></a>
    <a class="sourceLine" id="cb1-6" data-line-number="6">@inline @inbounds <span class="kw">function</span> lorenz(u, p, t)</a>
    <a class="sourceLine" id="cb1-7" data-line-number="7">    σ = p[<span class="fl">1</span>]; ρ = p[<span class="fl">2</span>]; β = p[<span class="fl">3</span>]</a>
    <a class="sourceLine" id="cb1-8" data-line-number="8">    du1 = σ*(u[<span class="fl">2</span>]-u[<span class="fl">1</span>])</a>
    <a class="sourceLine" id="cb1-9" data-line-number="9">    du2 = u[<span class="fl">1</span>]*(ρ-u[<span class="fl">3</span>]) - u[<span class="fl">2</span>]</a>
    <a class="sourceLine" id="cb1-10" data-line-number="10">    du3 = u[<span class="fl">1</span>]*u[<span class="fl">2</span>] - β*u[<span class="fl">3</span>]</a>
    <a class="sourceLine" id="cb1-11" data-line-number="11">    <span class="kw">return</span> SVector{<span class="fl">3</span>}(du1, du2, du3)</a>
    <a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">end</span></a>
    <a class="sourceLine" id="cb1-13" data-line-number="13"><span class="co"># A function for the Jacobian is useful but not necessary;</span></a>
    <a class="sourceLine" id="cb1-14" data-line-number="14"><span class="co"># If it is not given, automatic differentiation is used</span></a>
    <a class="sourceLine" id="cb1-15" data-line-number="15">@inline @inbounds <span class="kw">function</span> lorenz_jac(u, p, t)</a>
    <a class="sourceLine" id="cb1-16" data-line-number="16">    σ, ρ, β = p</a>
    <a class="sourceLine" id="cb1-17" data-line-number="17">    J = @SMatrix [-σ  σ  <span class="fl">0</span>;</a>
    <a class="sourceLine" id="cb1-18" data-line-number="18">    ρ - u[<span class="fl">3</span>]  (-<span class="fl">1</span>)  (-u[<span class="fl">1</span>]);</a>
    <a class="sourceLine" id="cb1-19" data-line-number="19">    u[<span class="fl">2</span>]   u[<span class="fl">1</span>]  -β]</a>
    <a class="sourceLine" id="cb1-20" data-line-number="20">    <span class="kw">return</span> J</a>
    <a class="sourceLine" id="cb1-21" data-line-number="21"><span class="kw">end</span></a>
    <a class="sourceLine" id="cb1-22" data-line-number="22"><span class="co"># typical chaotic initial condition:</span></a>
    <a class="sourceLine" id="cb1-23" data-line-number="23">u0=[<span class="fl">0.0</span>, <span class="fl">10.0</span>, <span class="fl">0.0</span>]</a>
    <a class="sourceLine" id="cb1-24" data-line-number="24"><span class="co"># parameters with strange attractor:</span></a>
    <a class="sourceLine" id="cb1-25" data-line-number="25">p = [<span class="fl">10</span>, <span class="fl">28</span>, <span class="fl">8</span>/<span class="fl">3</span>]</a>
    <a class="sourceLine" id="cb1-26" data-line-number="26"></a>
    <a class="sourceLine" id="cb1-27" data-line-number="27"><span class="co"># Create the dynamical system structure</span></a>
    <a class="sourceLine" id="cb1-28" data-line-number="28">ds = ContinuousDynamicalSystem(lorenz, u0, p, lorenz_jac)</a></code></pre></div>
    <pre><code>3-dimensional continuous dynamical system
     state:     [0.0, 10.0, 0.0]
     e.o.m.:    lorenz
     in-place?  false
     jacobian:  lorenz_jac</code></pre>
    <p>This structure can now be given to functions like <code>lyapunovs</code></p>
    <div class="sourceCode" id="cb3"><pre class="sourceCode julia"><code class="sourceCode julia"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co"># Calculate the full lyapunov spectrum by doing QR-decomposition 2000 times</span></a>
    <a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co"># and evolving in between for 2.0 units of time</span></a>
    <a class="sourceLine" id="cb3-3" data-line-number="3">λs = lyapunovs(ds, <span class="fl">2000</span>; dt = <span class="fl">2.0</span>)</a></code></pre></div>
    <pre><code>Float64[3]
    0.904…
    -0.000115…
    -14.6…</code></pre>
    <div class="sourceCode" id="cb5"><pre class="sourceCode julia"><code class="sourceCode julia"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># benchmark:</span></a>
    <a class="sourceLine" id="cb5-2" data-line-number="2">using BenchmarkTools</a>
    <a class="sourceLine" id="cb5-3" data-line-number="3">@btime lyapunovs($ds, <span class="fl">2000</span>; dt = <span class="fl">2.0</span>);</a></code></pre></div>
    <pre><code>  225.790 ms (348 allocations: 35.58 KiB)</code></pre>
    <p>Of course specific numbers change from run to run (random initialized Q-matrix).</p>
    <p>It is worth noting that the default differential equation solver used for continuous systems is a 9th order Vernier algorithm, with absolute and relative tolerances of <code>1e-9</code>. This must be taken into account before comparing benchmarks with other software. However, because of the excellent interaction of our library with the DifferentialEquations.jl suite <span class="citation" data-cites="Rackauckas2017">(Rackauckas and Nie 2017)</span>, it is very straight forward to use a different ODE solver.</p>
    <h2 id="information-dimension-from-delay-coordinates-embedding">Information Dimension from Delay Coordinates Embedding</h2>
    <p>Here we show how to analyze timeseries with <strong>DynamicalSystems.jl</strong>. We first generate example timeseries of the Hénon map <span class="citation" data-cites="Henon1976">(Henon 1976)</span> and then calculate the fractal dimension of the underlying attractor.</p>
    <div class="sourceCode" id="cb7"><pre class="sourceCode julia"><code class="sourceCode julia"><a class="sourceLine" id="cb7-1" data-line-number="1">ds = Systems.henon() <span class="co"># load one of the predefined systems</span></a>
    <a class="sourceLine" id="cb7-2" data-line-number="2"></a>
    <a class="sourceLine" id="cb7-3" data-line-number="3"><span class="co"># Get a trajectory of the system:</span></a>
    <a class="sourceLine" id="cb7-4" data-line-number="4">traj = trajectory(ds, <span class="fl">100000</span>)</a>
    <a class="sourceLine" id="cb7-5" data-line-number="5"></a>
    <a class="sourceLine" id="cb7-6" data-line-number="6"><span class="co"># A timeseries is univariate:</span></a>
    <a class="sourceLine" id="cb7-7" data-line-number="7">ts = traj[:, <span class="fl">1</span>] <span class="co"># first column of dataset</span></a>
    <a class="sourceLine" id="cb7-8" data-line-number="8"></a>
    <a class="sourceLine" id="cb7-9" data-line-number="9"><span class="co"># Now perform delay coordinates embedding of dimension 2 and delay 2:</span></a>
    <a class="sourceLine" id="cb7-10" data-line-number="10">R = Reconstruction(ts, <span class="fl">2</span>, <span class="fl">2</span>)</a>
    <a class="sourceLine" id="cb7-11" data-line-number="11"></a>
    <a class="sourceLine" id="cb7-12" data-line-number="12"><span class="co"># Now e.g. calculate the Information dimension</span></a>
    <a class="sourceLine" id="cb7-13" data-line-number="13">id = information_dim(R)</a>
    <a class="sourceLine" id="cb7-14" data-line-number="14"></a>
    <a class="sourceLine" id="cb7-15" data-line-number="15"><span class="co"># For reference, we can compute the information dimension of the</span></a>
    <a class="sourceLine" id="cb7-16" data-line-number="16"><span class="co"># Henon attractor directly, because we have a trajectory</span></a>
    <a class="sourceLine" id="cb7-17" data-line-number="17">id_direct = information_dim(traj, sizes)</a>
    <a class="sourceLine" id="cb7-18" data-line-number="18"></a>
    <a class="sourceLine" id="cb7-19" data-line-number="19">println(<span class="st">&quot;Dimensions: $(round(id, 4)), $(round(id_direct, 4))&quot;</span>)</a>
    <a class="sourceLine" id="cb7-20" data-line-number="20"></a>
    <a class="sourceLine" id="cb7-21" data-line-number="21"><span class="co"># Benchmark:</span></a>
    <a class="sourceLine" id="cb7-22" data-line-number="22">@btime Reconstruction($ts, <span class="fl">2</span>, <span class="fl">2</span>);</a>
    <a class="sourceLine" id="cb7-23" data-line-number="23">@btime information_dim($traj);</a></code></pre></div>
    <pre><code>Dimensions: 1.1979, 1.2
      653.181 μs (3 allocations: 1.53 MiB)
      590.347 ms (1819827 allocations: 118.57 MiB)</code></pre>
    <p>We note that the function <code>information_dim</code>, and other similar ones, computes a lot of automated steps by measuring entropies at many different partition sizes (by default 12) and deducing a scaling slope. All of these parameters can be changed by the user.</p>
    <h1 id="acknowledgements">Acknowledgements</h1>
    <p>We would like to thank Chris Rackauckas <span class="citation" data-cites="Rackauckas2017">(Rackauckas and Nie 2017)</span> for excellent help regarding the integration of the DifferentialEquations.jl suite to our library. We thank Takafumi Arakaki for contributing a method that computes the permutation entropy of a timeseries. We thank Sebastian Micluța-Câmpeanu for minor testing of continuous systems methods.</p>
    <h1 id="references" class="unnumbered">References</h1>
    <div id="refs" class="references">
    <div id="ref-Bezanson2017">
    <p>Bezanson, Jeff, Alan Edelman, Stefan Karpinski, and Viral B. Shah. 2017. “Julia: A Fresh Approach to Numerical Computing.” <em>SIAM Review</em> 59 (1):65–98. <a href="https://doi.org/10.1137/141000671" class="uri">https://doi.org/10.1137/141000671</a>.</p>
    </div>
    <div id="ref-Carpintero2014">
    <p>Carpintero, D. D., N. Maffione, and L. Darriba. 2014. “LP-VIcode: A program to compute a suite of variational chaos indicators.” <em>Astronomy and Computing</em> 5:19–27. <a href="https://doi.org/10.1016/j.ascom.2014.04.001" class="uri">https://doi.org/10.1016/j.ascom.2014.04.001</a>.</p>
    </div>
    <div id="ref-Datseris2017">
    <p>Datseris, George. 2017. “DynamicalBilliards.Jl: An Easy-to-Use, Modular and Extendable Julia Package for Dynamical Billiard Systems in Two Dimensions.” <em>The Journal of Open Source Software</em> 2 (19):458. <a href="https://doi.org/10.21105/joss.00458" class="uri">https://doi.org/10.21105/joss.00458</a>.</p>
    </div>
    <div id="ref-Diks2008">
    <p>Diks, Cees, Cars Hommes, Valentyn Panchenko, and Roy Weide. 2008. “E&amp;F chaos: A user friendly software package for nonlinear economic dynamics.” <em>Computational Economics</em> 32 (1-2):221–44. <a href="https://doi.org/10.1007/s10614-008-9130-x" class="uri">https://doi.org/10.1007/s10614-008-9130-x</a>.</p>
    </div>
    <div id="ref-Faust2015">
    <p>Faust, Gunter, John Argyris, Gunter Faust, Maria Haase, and Rudolf Friedrich. 2015. <em>An Exploration of Dynamical Systems and Chaos</em>. Springer.</p>
    </div>
    <div id="ref-Henon1976">
    <p>Henon, M. 1976. “A two-dimensional mapping with a strange attractor.” <em>Communications in Mathematical Physics</em> 50 (1):69–77. <a href="https://doi.org/10.1007/BF01608556" class="uri">https://doi.org/10.1007/BF01608556</a>.</p>
    </div>
    <div id="ref-Rackauckas2017">
    <p>Rackauckas, Christopher, and Qing Nie. 2017. “DifferentialEquations.jl – A Performant and Feature-Rich Ecosystem for Solving Differential Equations in Julia.” <em>Journal of Open Research Software</em> 5 (May). <a href="https://doi.org/10.5334/jors.151" class="uri">https://doi.org/10.5334/jors.151</a>.</p>
    </div>
    <div id="ref-Skokos2007">
    <p>Skokos, Ch., T.C. Bountis, and Ch. Antonopoulos. 2007. “Geometrical properties of local dynamics in Hamiltonian systems: The Generalized Alignment Index (GALI) method.” <em>Physica D: Nonlinear Phenomena</em> 231 (1):30–54. <a href="https://doi.org/10.1016/j.physd.2007.04.004" class="uri">https://doi.org/10.1016/j.physd.2007.04.004</a>.</p>
    </div>
    <div id="ref-Strogatz">
    <p>Strogatz, Steven H. 1995. <em>Nonlinear Dynamics and Chaos</em>. Perseus Books.</p>
    </div>
    </div>
  </body>
</article>
